// Copyright 2020 Google LLC
//
// Use of this source code is governed by an MIT-style license that can be found
// in the LICENSE file or at https://opensource.org/licenses/MIT.

use lazy_static::lazy_static;
use regex::Regex;

/// Performs group expansion on a given path.
/// For example, given path `foo/{bar,baz}/{quux,norf}` this method will yield
///   `foo/bar/quux`, `foo/bar/norf`, `foo/baz/quux`, `foo/baz/norf`.
/// The order of expansion is defined as if there were generated by `for` loops
/// nested in order of groups in the path.
///
/// Differences from GRR:
/// - support for empty value in the 1st and 2nd alternative e.g.:
///   - `/{,asd}`, `/{asd,}` are resolved here, but not in GRR
///   - `/{a,b,}` are resolved both in GRR and in here
/// - support for a single alternative e.g.:
///   - `/{asd}` is resolved here, but not in GRR
pub fn expand_groups(path: &str) -> Vec<String> {
    lazy_static! {
        static ref GROUPS_MATCHER: Regex = Regex::new(r"\{[^\{]+?\}").unwrap();
    }

    let mut offset = 0;
    let mut chunks: Vec<Vec<&str>> = vec![];

    for m in GROUPS_MATCHER.find_iter(path) {
        chunks.push(vec![&path[offset..m.start()]]);
        chunks.push(path[m.start() + 1..m.end() - 1].split(',').collect());
        offset = m.end();
    }
    chunks.push(vec![&path[offset..]]);

    join_chunks(chunks)
}

/// In the input the inner Vec is a list of alternatives available for
/// the chunk, the outer Vec is a list of chunks - e.g.
/// [["/home/"],
///  ["spawek/", "hanuszczak/"],
///  [".gitignore", ".hgignore"]]
///
/// The output consists of all the possible concatenations of all chunks in
/// the order of appearance, where exactly 1 alternative is used from each
/// chunk.
/// The order of alternatives is defined as if there were generated by `for`
/// loops nested in order of chunks.
///
/// Given the example input this function outputs:
/// ["/home/spawek/.gitignore",
///  "/home/spawek/.hgignore",
///  "/home/hanuszczak/.gitignore",
///  "/home/hanuszczak/.hgignore"].
fn join_chunks(chunks: Vec<Vec<&str>>) -> Vec<String> {
    if chunks.is_empty() {
        return vec![];
    }

    let mut ret: Vec<String> =
        chunks[0].iter().map(|x| (*x).to_owned()).collect();
    for chunk in chunks.into_iter().skip(1) {
        let mut new_ret = vec![];
        for prefix in ret {
            for suffix in &chunk {
                new_ret.push(prefix.to_owned() + suffix);
            }
        }
        ret = new_ret;
    }

    ret
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_expand_groups() {
        assert_eq!(expand_groups("/some/path"), vec!["/some/path"]);
        assert_eq!(
            expand_groups("/some/{1,2,3}"),
            vec!["/some/1", "/some/2", "/some/3"]
        );
        assert_eq!(
            expand_groups("/some/{1,2}/{3,4}"),
            vec!["/some/1/3", "/some/1/4", "/some/2/3", "/some/2/4"]
        );
        assert_eq!(
            expand_groups("/some/{1,}a/{3,}a"),
            vec!["/some/1a/3a", "/some/1a/a", "/some/a/3a", "/some/a/a"]
        );
        assert_eq!(expand_groups("/some/{123}"), vec!["/some/123"]);
    }

    #[test]
    fn test_join_chunks() {
        assert_eq!(
            join_chunks(vec![
                vec!["/home/"],
                vec!["spawek/", "hanuszczak/"],
                vec![".gitignore", ".hgignore"]
            ]),
            vec![
                "/home/spawek/.gitignore",
                "/home/spawek/.hgignore",
                "/home/hanuszczak/.gitignore",
                "/home/hanuszczak/.hgignore"
            ]
        );
    }
}
