// Copyright 2020 Google LLC
//
// Use of this source code is governed by an MIT-style license that can be found
// in the LICENSE file or at https://opensource.org/licenses/MIT.

use lazy_static::lazy_static;
use regex::{Regex};

/// Performs group expansion on a given path.
/// For example, given path `foo/{bar,baz}/{quux,norf}` this method will yield
///   `foo/bar/quux`, `foo/bar/norf`, `foo/baz/quux`, `foo/baz/norf`.
/// The order of expansion is defined as if there were generated by `for` loops nested in
/// order of groups in the path.
///
/// Differences from GRR:
/// - support for empty value in the 1st and 2nd alternative e.g.:
///   - `/{,asd}`, `/{asd,}` are resolved here, but not in GRR
///   - `/{a,b,}` are resolved both in GRR and in here
/// - support for a single alternative e.g.:
///   - `/{asd}` is resolved here, but not in GRR
pub fn resolve_path_alternatives(path: &str) -> Vec<String> {
    lazy_static! {
        static ref RE : Regex = Regex::new(r"\{[^\{]*?\}").unwrap();
    }

    let mut offset = 0;
    let mut chunks : Vec<Vec<String>> = vec![];

    for m in RE.find_iter(path){
        chunks.push(vec![path[offset..m.start()].to_owned()]);
        chunks.push(path[m.start()+1..m.end()-1].split(',').map(|x| x.to_owned()).collect());
        offset = m.end();
    }
    chunks.push(vec![path[offset..].to_owned()]);

    join_chunks(chunks)
}

fn join_chunks(chunks : Vec<Vec<String>>) -> Vec<String> {
    if chunks.is_empty(){
        return vec![];
    }

    let mut ret = chunks[0].clone();
    for chunk in chunks.into_iter().skip(1){
        let mut new_ret = vec![];
        for prefix in ret {
            for suffix in &chunk {
                new_ret.push(prefix.to_owned() + suffix);
            }
        }
        ret = new_ret;
    }

    ret
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn expand_groups_test()
    {
        assert_eq!(resolve_path_alternatives("/some/path"), vec!["/some/path"]);
        assert_eq!(resolve_path_alternatives("/some/{1,2,3}"), vec!["/some/1", "/some/2", "/some/3"]);
        assert_eq!(resolve_path_alternatives("/some/{1,2}/{3,4}"), vec!["/some/1/3", "/some/1/4", "/some/2/3", "/some/2/4"]);
        assert_eq!(resolve_path_alternatives("/some/{1,}a/{3,}a"), vec!["/some/1a/3a", "/some/1a/a", "/some/a/3a", "/some/a/a"]);
        assert_eq!(resolve_path_alternatives("/some/{123}"), vec!["/some/123"]);
    }
}
